# Chpater 12 Physical Layer - Logical(Gen3)//物理层逻辑（Gen3）

### 关于上一章

上一章介绍了物理层的 Gen1/Gen2 逻辑子模块。该层为串行传输和恢复准备数据包，并详细描述了完成这一任务所需的几个步骤。本章涵盖了与使用 8b/10b 编码/解码的 Gen1 和 Gen2 协议相关的逻辑。

### 关于本章

本章描述了第三代（Gen3）PCIe 的逻辑物理层特性。主要的变化包括相对于 Gen2 速度，带宽提高两倍，而不需要加倍频率（链路速度从 5 GT/s 到 8 GT/s）。这是通过在 Gen3 模式下取消 8b/10b 编码而实现的。在 Gen3 速度下，更鲁棒的信号补偿机制是必需的。

### 关于下一章

下一章将介绍物理层与链路的电气接口，并讨论了信号均衡的必要性和实现模型。本章结合了 Gen1、Gen2 和 Gen3 速度的电气发送端和接收端特性。

### 12.1 Gen3 简介

回顾一下，当 PCIe 链路进入训练时（即复位后），它总是开始使用 Gen1 速度以实现向后兼容。如果设备在训练期间宣称（advertise）了更高的速度，链路将立即转换到 Recovery 状态，并尝试将速率改为链路双方所支持的最高速度。

将 PCIe spec 升级到 Gen3 的主要动机是将带宽提高一倍，如第 408 页的表 12-1 所示。实现这一点的直接方法是简单地将信号频率从 5GT/s 增加到 10Gb/s，但这样做有几个问题：

• 更高的频率会消耗更多的功率，这种情况由于需要复杂的调节逻辑（均衡， equalization）来维持更高速度下的信号完整性而变得更加严重。事实上，在 PCISIG 的文献中提到，这种均衡逻辑的功率需求是保持尽可能低的频率的一个重要动机。

• 一些电路板材料在较高频率下会出现明显的信号衰减。这个问题可以通过更好的材料和更多的设计精力来克服，但这些会增加成本和开发时间。由于 PCIe 的目的是为各种系统服务，所以目标是它在廉价的设计中也应该运行良好。

• 同样，允许新设计使用现有的基础设施（例如电路板和连接器），可以最大限度地减少电路板设计工作和成本。使用更高的频率会使其变得更加困难，因为必须调整线路长度和其他参数以考虑到新的时序，这使得高频率变得不那么理想。

![image-20220701235159258](img/12%20%E7%89%A9%E7%90%86%E5%B1%82%E9%80%BB%E8%BE%91(gen3)/image-20220701235159258.png)     

这些考虑导致 Gen3 spec 与前几代相比有两个重大变化：新的编码模型和更复杂的信号均衡模型。

#### 12.1.1 新的编码模型

物理层的逻辑部分用新的 128b/130b 编码方案取代了 8b/10b 编码。当然，这意味着偏离了许多串行设计中所使用的众所周知的 8b/10b 模式。设计者愿意采取这一步骤来恢复 8b/10b 编码所带来的 20%的传输开销。使用 128b/130b 意味着通道（Lanes）现在传输的是 8 bits/byte，而不是 10 bits，这意味着 8.0GT/s 的数据速率，使带宽增加一倍。这相当于每个方向上的带宽为 1GB/s。

为了说明这两种编码的区别，首先考虑图 12-1，它显示了一般的 8b/10b 数据包结构。箭头强调了代表 8b/10b 数据包帧符号的控制（K）字符。接收端通过识别这些控制字符，知道应该期待什么。请参阅第 380 页的“8b/10b 编码”，了解这种编码方案的好处。

 

图 12-1 8b/10b 通道编码

相比之下，第 410 页的图 12-2 显示了 128b/130b 的编码。这种编码不影响正在传输的字节，而是将字符分组为 16 个字节的块，每个块的开头有一个 2 位的同步字段。2 位同步字段指定该块是否包括数据（10b）或有序集（01b）。因此，同步字段向接收端指出预期的流类型以及何时开始。有序集与 8b/10b 版本类似，它们必须同时在所有通道上驱动。这需要使通道正确地同步，这也是训练过程的一部分（见第 438 页“实现块对齐”）。

 

#### 12.1.2 更复杂的信号均衡模型

第二个变化是对物理层的电气子模块进行的，包括在链路的发送端和可选的接收端进行更复杂的信号均衡。Gen1 和 Gen2 的实现使用固定的 Tx 去加重（de-emphasis），以达到良好的信号质量。然而，将传输频率增加到 5GT/s 以上会导致信号完整性问题变得更加严重，需要更多的发送端和接收端补偿。这在一定程度上可以在板级上进行管理，但设计者希望让外部基础设施尽可能地保持不变，而将负担放在 PHY 发送端和接收端电路上。关于信号调节的更多细节，请参阅第 474 页的“8.0GT/s 的解决方案 – 发送端均衡（Transmitter Equalization）”。

### 12.2 8.0 GT/s 的编码

如前所述，Gen3 128b/130b 编码方法使用链路范围内的数据包和每条通道块编码。本节提供了关于编码的其他细节。

#### 12.2.1 通道级编码

为了说明块的使用，请看第 411 页的图 12-3，其中显示了一个单通道数据块。开始是两个同步头（Sync Header）位，后面是 16 个字节（128 位）的信息，共 130 个传输位。同步头简单地定义了正在发送的是一个数据块(10b)还是一个有序集(01b)。你可能已经注意到图 12-3 中的数据块的同步头值是 01，而不是上面提到的 10b 值。这是因为在链路上传输数据块时，首先发送同步头的最低有效位。请注意，同步头后面的符号也会先以最低有效位发送。

 

#### 12.2.2 块对齐

与以前的实现方式一样，Gen3 首先实现位锁定，然后尝试建立块对齐锁定。这需要接收端找到划分块边界的同步头。发送端通过发送由 00h 和 FFh 交替字节组成的可识别的 EIEOS 模式建立这一边界，如图 12-4 所示。因此，EIEOS 的使用已从简单的退出电气空闲扩展到作为建立块对齐的同步机制。请注意，同步头位紧接在 EIEOS 之前和之后（图中未显示）。关于这个过程的细节，请参见第 438 页的“实现块对齐”。

 

#### 12.2.3 有续集块

有续集的含义与 Gen1 和 Gen2 中的含义基本相同。它们用于管理通道协议。当发送有序集块时，它必须同时出现在所有通道上，并且几乎总是由 16 个字节组成，只有一个例外。这个大小规则的一个例外是 SOS（SKP 有序集），它可以通过时钟补偿逻辑（例如与链路中继器（Link Repeater）相关）以四个为一组的形式添加或删除 SKP 符号，因此可以合法地成为 8、12、16、20 或 24 字节长。

有序集块的基本格式与数据块类似，只是同步头位是相反的，如第 412 页图 12-5 所示。

 

该规范为 Gen3 定义了七个有序集（比 Gen1 和 Gen2 PCIe 多一个有序集）。在大多数情况下，它们的功能与前几代相同。

\1. SOS - Skip Ordered Set：用于时钟补偿。更多细节见第 426 页“有序集示例-SOS”。

\2. EIOS - 电气空闲有序集（Electrical Idle Ordered Set）：用于进入电气空闲状态

\3. EIEOS - 电气空闲退出有序集（Electrical Idle Exit Ordered Set）：现在用于两个目的：

— 电气空闲退出与以前一样

— 8.0GT/s 的块对齐指示器

\4. TS1 - 训练序列 1 有序集（Training Sequence 1 Ordered Set）

\5. TS2 - 训练序列 2 有序集（Training Sequence 2 Ordered Set）

\6. FTS - 快速训练序列有序集（Fast Training Sequence Ordered Set）

\7. SDS - 数据流有序集的开始（Start of Data Stream Ordered Set）：新的 - 详见第 413 页“数据流和数据块”。

为了给读者一个有序集结构的示例，图 12-6 显示了在 8.0GT/s 下运行时 FTS 有序集的内容。一个有序集块只有通过同步头才能被识别为有序集，并通过该块中的第一个符号识别为 FTS 类型。图的右侧列出了有序集标识符（每个有序集的第一个符号），用于识别正在传输的有序集的类型。

 

#### 12.2.4 数据流和数据块

链路通过发送一个 SDS 有序集并转换到 L0 链路状态来进入数据流。在数据流中传输多个数据块，直到数据流以 EDS 标记（Token）结束（除非有错误提前结束）。 EDS 标记总是占据有序集之前的数据块的最后四个符号。Skip 有序集是一个例外，因为只要符合某些条件，它们就不会中断数据流。遇到这种情况，将在后面讨论。当链路状态从 L0 状态转换到任何其他链路状态，如恢复（Recovery），数据流就不再有效。关于链路状态的更多信息，请参阅第 518 页的“链路训练和状态机（LTSSM）”。

#### 12.2.5 数据块帧结构

数据块由用于传递信息的 TLPs、DLLP 和 Token 组成。在一个数据块中还使用了五种类型的数据结构（称为标记）。每一种都有便于接收端检测的模式。其中三种标记可以在一个块的开头发送（即，紧跟在同步数据块之后）。其中包括：

• 开始 TLP（STP） - 随后是 TLP 

• 开始 DLLP（SDP） - 随后是 DLLP

• 逻辑空闲（IDLA） - 在没有数据包活动时发送

剩余的标记（Tokens）在数据块的末尾传递。

• 数据流结束（EDS） - 在转换到有序集之前

• End Bad (EDB) - 报告检测到无效的数据包

图 12-7 提供了一个由单通道 TLP 传输组成的数据块的示例。

 

总之，给定数据块的内容因活动而异：

• IDLs - 当没有数据包被传送时，数据块只由 IDL 组成。(规范将 IDL 指定为标记之一）。

• TLPs - 在一个给定的数据块中可以发送一个或多个 TLPs，取决于链路宽度。

• DLLPs - 一个数据块中可以发送一个或多个 DLLPs。

• 上述活动的组合可在一个数据块中传送。

##### 12.2.5.1 帧标记

该规范定义了五个允许出现在数据块中的帧标记（或简称为“标记”），为了方便起见，在第 417 页的图 12-8 中重复了这些标记。这五个标记是。

\1. STP - 开始 TLP：与早期版本很相似，但现在包括整个数据包的双字（dword）数。

\2. SDP - 开始 DLLP

\3. EDB - End Bad。用于使 TLP 无效，就像在早期的 Gen1 和 Gen2 设计中那样，但现在会连续发送四个 EDB 符号。现在已经取消了 END（结束良好）符号；如果没有明确标记为坏，TLP 将被假定为良好。

\4. EDS - 数据流的结束。数据流的最后一个双字（dword），表示至少有一个有序集将会出现。奇怪的是，数据流可能并没有因为这个事件而真正结束。如果紧随其后的有序集是 SOS，并且紧随其后的是另一个数据块，则数据流继续。如果跟随 EDS 的有序集不是 SOS，或者如果 SOS 后面没有数据块，那么数据流就会结束。

\5. IDL - 逻辑空闲。空闲标记只是在链路逻辑空闲状态下，没有 TLPs 或 DLLPs 准备传输时发送的数据零字节（data zero bytes）。

规范中显示标记的方式与第 417 页图 12-8 中显示的方式的不同之处在于，这幅图以小端（little-endian）顺序显示字节和位，而不是规范中使用的大端（big-endian）位表示。之所以这样显示，是为了说明位在通道上实际出现的顺序。

##### 12.2.5.2 数据包

STP 和 SDP，表示一个数据包的开始，如图 12-7 所示

• TLPs。一个 STP 标记由一个 1 的半字节组成，后面是一个 11 位的双字长字段。该长度统计 TLP 的所有双字，包括标记、头、可选的数据有效载荷、可选的摘要（digest）和 LCRC。这使接收端能够计算双字数，以识别 TLP 的结束位置。因此，验证 Length 字段没有错误是非常重要的，因此它有一个 4 位的帧 CRC（Frame CRC），以及一个保护 Length 和帧 CRC 字段的偶数奇偶校验位。这些位的组合为标记提供了强大的三位翻转（triple-bit-flip）检测能力（多达 3 位可能不正确，但仍然会被识别为错误）。11 位的长度字段允许整个 TLP 为 2K 双字（8KB）。

• DLLPs。SDP 标记表示 DLLP 的开始，不包括长度字段，因为它总是正好 8 个字节长：2 个字节的标记后面是 4 个字节的 DLLP 有效载荷和 2 个字节的 DLLP LCRC。也许是巧合，这个 DLLP 长度与前几代 PCIe 相同，但它们也没有一个结束良好的符号。

EDB 标记被添加到无效的 TLPs 的末尾。对于一个正常的 TLP，没有“结束良好”的指示；除非明确标记为坏，否则它被认为是良好的。如果 TLP 最终被标记为无效，LCRC 值将被反转，并附加一个 EDB 标记作为 TLP 的扩展，尽管它不包括在长度值中。物理层的接收端必须在每个 TLP 结束时检查 EDB，如果看到 EDB 就通知链路层。毫不奇怪，除了在 TLP 之后立即接收 EDB 之外，任何时候接收 EDB 都将被视为帧错误。

 

##### 12.2.5.3 发送端帧要求

为了开始这个讨论，首先要定义一些东西，这将是有帮助的。首先，回顾一下，数据流从 SDS 之后的第一个符号开始，它可能包含由标记、TLP 和 DLLP 组成的数据块。数据流以 SOS 以外的有序集之前的最后一个符号结束，或者当检测到帧错误时结束。在数据流期间，除了 SOS 外，不能发送任何有序集。

其次，由于帧问题通常会导致帧错误，这将有助于解释在这种情况下发生什么。当帧错误发生时，它们被视为接收端错误，并将被报告为接收端错误。接收端停止处理正在进行的数据流，只有当它看到一个 SDS 有序集时才会处理一个新的数据流。为了响应错误，通过将 LTSSM 从 L0 引导到恢复（Recovery）状态来启动恢复过程。预期这将在物理层得到解决，不需要上层采取任何行动。此外，规范指出，从两个端口进入恢复状态开始，完成这一过程的往返时间预计不到 1us。

现在，有了这个背景，让我们继续讨论帧要求。在数据流中，发送端必须遵守以下规则：

• 当发送 TLP 时：

— STP 标记必须紧跟着从链路层传递的 TLP 的全部内容，即使它是无效的。

— 如果 TLP 是无效的，EDB Token 必须紧跟在 TLP 的最后一个 dword 之后，但不能包含在 TLP 的长度值中。

— STP 不能在链路上的每个符号时间内发送多次。

• 当发送 DLLP 时：

— SDP 标记后面必须紧跟着从数据链路层传递的 DLLP 的全部内容。

— SDP 在链路上的每个符号时间内不能被发送多次。

• 当在数据流中发送一个 SOS（SKP 有序集）时：

— 在当前数据块的最后一个双字中发送一个 EDS 标记。

— 将 SOS 作为下一个有序集块发送。

— 在 SOS 之后立即发送另一个数据块。数据流以该后续数据块的第一个符号恢复。

— 如果安排了多个 SOS，它们就不能像前几代那样背对背地进行。相反，每个标记前面必须有一个以 EDS 标记结束的数据块。在此期间，数据块可以用 TLPs、DLLPs 或 IDLs 填充。

• 要结束一个数据流，在当前数据块的最后一个双字中发送 EDS 标记，然后使用 EIOS 进入低功率链路状态，或者用 EIEOS 处理所有其他情况。

• 如果链路上没有发送 TLP、DLLP 或其他帧标记，则必须在所有通道上发送 IDL 标记。

• 对于多通道链路：

— 在发送一个 IDL 标记后，下一个 TLP 或 DLLP 的第一个符号在开始时必须位于通道 0 中。EDS 标记必须始终是数据块的最后一个双字，因此可能不总是遵循这一规则。

— IDL 标记必须被用来在符号时间内填充本来是空的双字。例如，如果一个 x8 链路的 TLP 在通道 3 结束，但发送端没有另一个 TLP 或 DLLP 准备在通道 4 开始，那么 IDL 必须填充剩余的字节，直到该符号时间的结束。

— 由于数据包仍然是 4 字节的倍数，就像它们在早期几代中一样，它们将在 4 通道边界开始和结束。例如，在通道 3 结束的具有 DLLP 的 x8 链路，可以通过将其 STP 标记放在通道 4 来开始下一个 TLP。

##### 12.2.5.4 接收端帧要求

当在接收端看到数据流时，以下规则适用：

• 当需要帧标记时，看起来像其他东西的符号将是帧错误。

• 下面列表中显示的一些错误检查和报告是可选的，规范中指出它们是独立可选的。

• 当收到 STP 时：

— 接收端必须检查帧 CRC 和帧奇偶校验字段，任何不匹配都将是一个帧错误。(注意，在报告这个错误时，带有帧错误的 STP 标记不被认为是 TLP 的一部分。)。

— 紧接 TLP 最后一个 DW 的符号是下一个要处理的标记，接收端必须检查它是否是 EDB 标记的开始，表明 TLP 已经无效。

— 可选择检查长度值是否为零；如果检测到，则为帧错误。

— 可选择检查在同一符号时间内是否有多个 STP 标记到达。如果检查并检测到，这就是一个帧错误。

• 当收到 EDB 时：

— 一旦检测到第一个 EDB 符号，或者在接收到它的任何剩余字节之后，接收端必须立即通知链路层。

— 如果标记中的任何符号都不是 EDB，则结果是一个帧错误。

— EDB 标记的唯一合法时间是在 TLP 之后；任何其他用途都将是帧错误。

— 紧跟在 EDB 标记之后的符号将是要处理的下一个标记的第一个符号。

• 当 EDS 标记作为数据块的最后一个 DW 被接收时：

— 接收端必须停止处理数据流。

— 接下来，只接受 SKP、EIOS 或 EIEOS 有续集；接收任何其他有序集都将是帧错误。

— 如果在 EDS 之后收到 SKP 有序集，则除非检测到帧错误，否则接收端必须使用随后的数据块的第一个符号（Symbol）恢复数据流处理。

• 当收到 SDP 标记时：

— 紧随 DLLP 之后的符号是下一个要处理的符号。

— 可选择在同一符号时间内检查多个 SDP 标记。如果检查并出现这种情况，则为帧错误。

• 当收到 IDL 标记时：

— 允许下一个标记在 IDL 标记之后的任何 DW 对齐的通道上开始。对于 x4 或更窄的链路，这意味着下一个标记只能在下一个符号时间的通道 0 开始。对于更宽的链路，有更多的选择。例如，x16 链路可以在当前符号时间的 0、4、8 或 12 通道开始下一个标记。

— 唯一可望与 IDL 在同一符号时间内的标记是另一个 IDL 或 EDS。

• 在处理数据流时，接收端将以下视为帧错误：

— 紧跟着 SDS 之后的有序集。

— 具有非法同步头（11b 或 00b）的块。这可以选择性地在通道错误状态（Lane Error Status）寄存器中报告。

— 任何通道上的有续集块，未在前一个块中收到 EDS 标记。

— 紧跟在前一个块中的 EDS 标记之后的数据块。

— 可以选择验证所有通道是否收到相同的有序集。

##### 12.2.5.5 从帧错误中恢复

如果在处理数据流时发现帧错误，接收端必须：

• 报告接收端错误（如果可选的高级错误报告（Advanced Error Reporting）寄存器可用，则设置第 421 页图 12-9 所示的状态位）。

• 停止处理数据流。当看到下一个 SDS 有序集时，可以开始处理新的数据流。

• 启动错误恢复过程。如果链路处于 L0 状态，则需要转换到恢复状态。该规范规定，恢复状态的时间“预计”小于 1us。

• 请注意，从帧错误中恢复不一定会通过 Ack/Nak 机制直接导致数据链路层发起的恢复活动。当然，如果 TLP 由于错误而丢失或损坏，那么将需要重放事件（replay event）。

 

### 12.3 Gen3 物理层发送逻辑

第 422 页的图 12-10 显示了支持 Gen3 速度的物理层传输逻辑的概念框图。整体设计与 Gen2 非常相似，所以没有必要再去看所有的细节，但也有一些区别。鼓励 PCIe 新手回顾第 361 页的“物理层-逻辑（Gen1 和 Gen2）”一章，以了解物理层设计的基础知识。让我们从图的顶部开始，解释 Gen3 在整个过程中所做的更改。与之前一样，需要指出的是，这个实现仅用于教学目的，并不是为了展示实际的 Gen3 物理层实现。

#### 12.3.1 多路复用器

TLP 和 DLLP 来自顶部的数据链路层。多路复用器混入构建完整 TLP 或 DLLP 所需的 STP 或 SDP 标记。上一节描述了标记格式。

 

Gen3 TLP 的边界由 TLP 数据包开始时 STP 标记长度字段中的双字计数定义，因此，不需要 END 帧字符。

当结束数据流时或在发送 SOS 之前，EDS 标记被混入数据流。根据跳转计时器，多路复用器定期将 SOS 插入数据流中。其他有序集，如 TS1、TS2、FTS、EIEOS、EIOS、SDS 也可以根据链路要求进行多路复用，并且不在数据流范围内。

数据包在由 2 位同步头标识的块中传输。同步头由多路复用器添加。但是，通过字节条带化（Byte Striping）逻辑在多通道链路的所有通道上复制同步头。

当没有要发送的数据包或有序集，但链路在 L0 状态下保持活动时，IDL（逻辑空闲，或数据零）标记被用作填充符。这些标记就像其他数据字节一样被加扰，并被接收端识别为填充符。

#### 12.3.2 字节条带化（Byte Striping）

这种逻辑将要传送的字节分布在所有可用的通道上。帧规则已在第 417 页“发送端帧要求”中进行了描述，现在让我们看一些示例并讨论如何应用这些规则。

首先考虑第 424 页图 12-11 所示的示例，其中说明了 4 通道链路。注意，当一个新的块开始时，同步头位同时出现在所有通道上，并定义了块的类型（本例中是数据块）。块编码对于每个通道都是独立处理的，但字节（或符号）在所有通道上都是条带化（striped）的，就像早期几代 PCIe 一样。

 

##### 12.3.2.1 字节条带化 x8 示例

接下来，考虑第 425 页图 12-12 所示的 x8 链路，这是重新绘制的规范中的一个示例，以便于阅读。这里的比特流是垂直的，而不是水平的。在顶部，我们可以看到同步位，按要求以小端顺序显示，同时出现在所有通道上，并指示数据块正在启动。

在此示例中，首先发送 TLP，所以符号 0-4 包含 STP 帧标记，包括标记在内的整个 TLP 长度为 7DW。接收端需要知道 TLP 的长度，因为对于 8GT/s 速度，没有 END 控制字符。相反，接收端统计双字，如果没有观察到 EDB（End Bad），则认为 TLP 是好的。在这种情况下，TLP 在符号 3 的通道 3 结束。

 

接下来，从通道 4 和 5 上的 SDP 标记开始发送 DLLP。由于 DLLP 的长度始终为 8 个符号，因此它将在符号 4 的通道 3 结束。暂时，没有其他数据包要发送，因此 IDL 符号将被传输，直到另一个数据包准备就绪。发送 IDL 时，下一个 STP 标记只能在通道 0 中启动。在本例中，TLP 从符号 6 的通道 0 开始。

下一个 TLP 的数据包长度为 23 DW，这是一个有趣的情况，因为在下一个块边界之前只有 20 个双字（dwords）可用。当数据块结束时，发送端发送同步，并在下一个数据块的符号 0 期间继续 TLP 传输。换句话说，数据包只是在必要时跨越块边界。最后，TLP 在符号 1 的通道 3 完成。再一次，没有准备好发送的数据包，因此发送 IDL。

##### 12.3.2.2 无效的数据包 x8 示例

当通过交换器传输 TLP 以减少延迟时，可能会出现无效的 TLP。这称为交换器直通（Switch Cut-Through）操作。在继续讨论之前，读者可以选择阅读第 354 页标题为“交换器直通模式（Switch Cut-Through Mode）”的部分。

当交换器在入端口收到数据包之前和错误检查之前将数据包转发到出端口时，可能会出现无效的 TLP。因为在此例中检测到了一个错误，因此 TLP 必须是无效的。

图 12-13 说明了取消 TLP 所采取的步骤。出口端口发送的 TLP 从第一个块（符号 6 的通道 0）开始。当检测到错误时，出口端口反转 CRC（符号 1 的通道 0-3），并在 TLP（符号 1 的通道 4-7）之后立即添加 EDB 令牌。这两项更改一起向接收方表明，该 TLP 已被取消，应予以丢弃。请注意，EDB 字节不包括在数据包长度字段中，因为当发生错误时，它们会动态添加到飞行中的数据包中。

图 12-13 说明了使 TLP 无效的步骤。出端口发送的 TLP 从第一块开始（符号 6 的通道 0）。当检测到错误时，出端口反转 CRC（符号 1 的通道 0-3），并在 TLP（符号 1 的通道 4-7）之后立即添加一个 EDB 标记。这两个更改一起向接收端表明，这个 TLP 已经无效，应该被丢弃。请注意，EDB 字节不包括在数据包长度字段中，因为当发生错误时，它们会动态地添加到飞行的数据包中。

 

##### 12.3.2.3 有序集示例 – SOS

现在我们来考虑一个有序集传输的示例。如第 427 页图 12-14 所示，一个有序集由 2 位同步头值 01b 表示。接下来的字节将被接收端理解为构成一个长度为 16 字节（128 比特）的有序集。唯一的例外是 SOS（Skip Ordered Set），因为它可以被中间接收方以每次 4 个字节的增量改变，用于时钟补偿。因此，允许一个 SOS 的长度为 8、12、16、20 或 24 个符号是合法地。如果没有不在 SOS 中添加或删除 SKP 的链路中继器设备，SOS 也将由 16 个字节组成。

为了说明有序集，让我们用一个 SOS 来展示各种特征以及它们是如何一起工作的。考虑一下第 428 页的图 12-15，其中数据块后面是 SOS。帧规则规定，前一个数据块必须以最后一个双字中的 EDS 标记结束，以便让接收端知道一个有序集即将到来。如果当前的数据流要继续下去，则后面的有序集必须是 SOS，而且后面必须依次是另一个数据块。本例并未说明这一点，但 TLP 有可能在这一点上没有完成，并通过在必须紧跟 SOS 的数据块中恢复传输来跨越 SOS。

收到 EDS 标记意味着数据流要么结束，要么暂停以插入一个 SOS。EDS 是唯一可以在与 IDL 相同的符号时间内，在双字对齐的通道上开始的标记，这个例子就是这样，从符号时间 15 的第 4 通道开始。回顾一下，EDS 也必须在数据块的最后一个双字里。根据接收端的帧要求，在 EDS 之后只允许有一个有序集块，而且必须是 SOS、EIOS 或 EIEOS，否则将被视为成帧错误。与早期规格版本一样，有序集必须同时出现在所有通道上。接收端可以选择检查以确保每个通道看到相同的有序集。

在我们的例子中，接下来看到的是一个 16 字节的 SOS，它是由有序集的 Sych Header 以及 SKP 字节模式识别的。在 SOS 的末尾始终有 4 个符号，包含了当前 24 位加扰器 LFSR 状态。在符号 12 中，接收端知道 SKP 字符已经结束，同时也知道该块还有三个字节要在每条通道上传输。这些是加扰逻辑 LFSR 的输出，如第 428 页的表 12-2 所示。

 

表 12-2 Gen3 16 位 Skip Ordered Set 编码

| **符号编号** | **值** | **描述**                                                     |
| ------------ | ------ | ------------------------------------------------------------ |
| 0-11         | AAh    | SKP 符号。由于符号 0 是有序集的标识符，因此它被视为 SOS。        |
| 12           | E1h    | SKP_END 符号，表示再过 3 个符号后，SOS 将完成。                  |
| 13           | 00-FFh | a) 如果 LTSSM 状态为 Polling.Compliance：AAh  b) 否则，如果前一个块是数据块：  位[7]=数据奇偶校验  位[6:0]=LFSR[22:16]  c) 其他  位[7]=~LFSR[22]  位[6:0]=LFSR[22:16] |
| 14           | 00-FFh | a) 如果 LTSSM 的状态是 Polling.Compliance：Error_Status[7:0]  b) 否则 LFSR[15:8] |
| 15           | 00-FFh | a) 如果 LTSSM 的状态是 Polling.Compliance：Error_Status [7:0]  b) 否则 LFSR[7:0] |

表中提到的数据奇偶校验位是自最近的 SDS 或 SOS 以来发送的所有数据块加扰字节的偶校验，并且为每个通道独立创建。接收端需要计算和检查奇偶校验。如果位不匹配，则必须设置与出现错误的通道对应的通道错误状态（Lane Error Status）寄存器位，但这不被视为接收端错误，也不启动链路重新训练。

8 位的 Error_Status 字段只有在 LTSSM 处于 Polling.Compliance 状态时才有意义（详情见第 529 页的“Polling.Compliance”）。对于我们的数据块之后的 SOS 例子，第 13 字节是数据奇偶校验位和 LFSR[22:16]，而最后两个字节是 LFSR 位[15:0]。

##### 12.3.2.4 发送端 SOS 规则

使用 128b/130b 时，发送端的 SOS 规则包括。

• 一个 SOS 必须安排在 370 至 375 个块内发生。然而，在 Loopback 模式下，Loopback Master 必须在该时间内安排两个 SOS，而且它们之间的距离不得超过两个块。

• SOS 仍然只能在数据包边界发送，因此可能会累积，但是，连续的 SOS 是不允许的；它们必须由数据块进行分离。

• 建议每当发送端处于电气空闲状态时，复位 SOS 计时器和计数器。

• 使用 128b/130b 时，链接控制寄存器 2 中的一致性（Compliance）SOS 位无效。(它用来在 8b/10b 的一致性测试中禁用 SOS，但这不是 128b/130b 的选项）。

##### 12.3.2.5 接收端 SOS 规则

使用 128b/130b 时，接收端的跳过有序集（Skip Ordered Set）规则包括：

• 他们必须容忍以平均 370-375 个块的平均间隔接收 SOS。请注意，电气空闲后的第一个 SOS 可能会提前到达，因为发送端不需要在电气空闲时间内复位 SOS 计时器。

• 接收端必须检查数据流中的每个 SOS 之前都有一个以 EDS 结尾的数据块。

#### 12.3.3 加扰

128b/130b 的加扰逻辑是从前几代 PCIe 修改而来的，以解决 8b/10b 编码自动处理的两个问题：保持 DC 平衡和提供足够的转换密度。回顾一下，DC 平衡意味着比特流中的 1 和 0 的数量相等。这是为了避免“DC wonder”的问题，即传输介质向一个或另一个电压充电过多，通常为 1 或 0，以至于难以在必要的时间内切换信号。另一个问题是，接收端的时钟恢复需要在输入信号中看到足够的边缘（edge），以便能够将它们与恢复的时钟进行比较，并根据需要调整时间和相位。

在没有 8b/10b 来处理这些问题的情况下，采取了三个步骤：第一，新的加扰方法在较长的时间段内改善了转换密度和 DC 平衡，但不能像 8b/10b 那样在短期内保证它们。第二，训练期间使用的 TS1 和 TS2 有序集模式包括根据需要调整的字段，以改善 DC 平衡。第三，接收端必须比前几代更强大，更能容忍这些问题。

##### 12.3.3.1 LFSR 的数量

在较低的数据速率下，每条通道都以相同的方式进行加扰，因此一个线性反馈移位寄存器（LFSR）可以为所有的通道提供加扰输入。然而，对于 Gen3，设计者希望为相邻的通道提供不同的加扰值。其原因可能包括希望通过加扰彼此的输出来减少通道之间串扰的可能性，并避免在每个通道上有相同的值，就像发送 IDL 时可能发生的那样。该规范描述了实现这一目标的两种方法，一种是强调更低的延迟，另一种是强调更低的成本。

###### 12.3.3.1.1 第一种选择：多个 LFSR

**第一种选择**：**多个****LFSR**。一种解决方案是为每个通道实现一个单独的 LFSR，并用不同的起始值或“种子”来初始化每个通道。这具有简单和快速的优点，但代价是增加了逻辑。如图 12-16 所示，每个 LFSR 根据规范中给出的多项式 G(X)=X23+X21+X16+X8+X5+X2+1 创建一个伪随机输出。这个多项式比以前的版本要长，而且由于种子值的不同，其表现也有一些不同。每个通道的八个不同的种子值需要八个不同的 LFSR，每个通道 0 到 7 各一个。

 

第 432 页的表 12-3 列出了每个通道的 24 位种子值。该系列会自我重复，这意味着通道 8 的种子值将与通道 0 相同，因此仅显示前 8 个值。每个通道使用相同的 LFSR 和相同的分接点（tap point）来创建加扰输出，不同的种子值会产生所需的差异。

 

###### 12.3.3.1.2 第二种选择：单个 LFSR

**第二种选择：单 LFSR**：另一种解决方案，如第 433 页图 12-17 所示，用于通道 2、10、18 和 26，是只使用一个 LFSR，并通过将不同的分接点 XOR 在一起为每个通道创建加扰输入。由于只有一个 LFSR，所有通道的种子值是相同的（全 1 - all ones），但每个通道的加扰“分接等式（Tap Equation）”是由不同的分接点组合而成的，如第 433 页的表 12-4 所示。该规范还指出，4 个通道的分接等式可以通过 XOR 它们的位邻的分接值而得到。

• Lane 0 = Lane 7 XOR Lane 1（注意，前往较低的通道数的过程是环绕的，因此 Lane 7 被认为比 Lane 0 低）。

• Lane 2 = Lane 1 XOR Lane 3

• Lane 4 = Lane 3 XOR Lane 5

• Lane 6 = Lane 5 XOR Lane 7

单 LFSR 解决方案使用的门数比多 LFSR 版本少，但通过 XOR 过程产生了额外的延迟，提供了一个不同的成本/性能选择。

 

 

##### 12.3.3.2 加扰规则

Gen3 加扰器 LFSR（无论是一个还是多个）并不持续推进（advance），而只是根据正在发送的内容推进。加扰器必须定期重新初始化，每当看到 EIEOS 或 FTSOS 时都会进行初始化。为方便起见，规范给出了以下几种加扰规则： 

• 同步头位没有被加扰，也没有推进 LFSR。

• 当最后一个 EIEOS 符号被发送时，发送端 LFSR 被复位，当最后一个 EIEOS 符号被接收时，接收端 LFSR 被复位。

• TS1 和 TS2 有序集：

— 符号 0 绕过加扰

— 符号 1 至 13 被加扰

— 符号 14 和 15 可能会也可能不会被加扰。规范规定，如果有必要改善 DC 平衡，它们将绕过加扰，否则将加扰（关于如何保持 DC 平衡的更多细节，见第 510 页的“TS1 和 TS2 有序集”）。

• 有序集 FTS、SDS、EIEOS、EIOS 和 SOS 的所有符号都绕过了加扰。尽管如此，输出的数据流将有足够的转换密度以允许时钟恢复，而且为有序集选择的符号将导致 DC 平衡输出。

• 即使旁路（bypassed）时，发送端对所有有序集符号推进它们的 LFSR，除了 SOS 中的符号。

• 接收端也是这样做的，检查传入的有序集的符号 0，看它是否是 SOS。如果是的话，LFSRs 就不会对该块中的任何符号进行推进。否则，LFSR 对该块中的所有符号进行推进。

• 所有的数据块符号被加扰并推进 LFSRs。

• 符号是按小端顺序进行加扰，也就是说，这意味着最低有效位首先加扰，最高有效位最后加扰。

• 每个通道 LFSR 的种子值取决于 LTSSM 第一次进入 Configuration.Idle（已完成轮询状态）时分配给该通道的通道数。第 432 页的表 12-3 中显示了模数为 8 的种子值，一旦分配，只要 LinkUp=1，就不会改变，即使通道分配因回到配置状态而被改变。

• 与 8b/10b 不同，在使用 128b/130b 编码时，不能禁用加扰器，因为需要它来帮助实现信号完整性。如果没有加扰，预计链路不会可靠地运行，因此它必须始终处于打开状态。

• Loopback Slave 不得对回环（loope-back）位进行加扰或解扰。

#### 12.3.4 串行器

这个移位寄存器的工作方式与 Gen1/Gen2 数据速率的工作方式类似，只是它现在一次接收 8 位，而不是 10 位（即，串行器是一个 8 位并行到串行移位寄存器）。

#### 12.3.5 用于同步头位的多路复用器

最后，必须注入两个同步头位，以区分下一个字符块是数据块还是有序集块。这是每一个 130 位块的前两位，它们的逻辑可以添加到发送端中对设计有意义的任何位置。在这本例中，为了简单起见，这些位是在过程的最后注入的。无论他们包含在何处，上面的字节流必须停顿下来，以便为它们留出时间。在本例中，需要有一种方法来通知上述的逻辑暂停两个比特的时间。在发送同步位期间，传入的数据包流将在 Tx 缓冲区中排队。

### 12.4 Gen3 物理层接收逻辑

与前几代一样，接收端的逻辑，如第 436 页图 12-18 所示，从 CDR（时钟和数据恢复，Clock and Data Recovery）电路开始。这可能包括 PLL，该 PLL 根据预期频率和比特流中的边缘锁定发送端时钟的频率，以产生恢复的时钟（Rx 时钟）。这个恢复时钟将输入位锁存到反串行化缓冲器中，然后，一旦建立了块对齐（在 LTSSM 的恢复状态下），另一个被 8.125 除的恢复时钟版本（Rx Clock/8.125）将 8 位符号锁入弹性缓冲器中。之后，解扰器从加扰的字符中重新创建原始数据。这些字节绕过 8b/10b 解码器，直接被送到字节拆分（Byte Un-striping）逻辑。最后，有序集被过滤掉，剩下的 TLPs 和 DLLPs 字节流被转发到数据链路层。

在下面的讨论中，将从底部向上描述每个部分。重点是描述为 8.0GT/s 改变的物理层的各个方面。本节将不对 Gen1/Gen2 的子块进行描述。

#### 12.4.1 差分接收

差分接收端的逻辑没有变化，但存在改善信号完整性的电气变化（参见第 468 页的“信号补偿”），以及建立信号均衡的训练变化，这在第 577 页的“链路均衡概述”中有所介绍。

 

#### 12.4.2 CDR（时钟和数据恢复）逻辑

##### 12.4.2.1 Rx 时钟恢复

尽管新的加扰方案有助于时钟恢复，但它并不能保证在短间隔内有良好的转换密度。因此，CDR 逻辑现在必须能够在没有那么多边缘的情况下保持较长时间的同步。规范中没有给出实现这一目标的具体方法，但可能需要一个更强大的 PLL（锁相环，Phas-Locked Loop）或 DLL（延迟锁相环，Delay-Locked Loop）电路。

CDR 逻辑的另一个不同之处在于，弹性缓冲器使用的内部时钟并不像人们想象的那样简单地将 Rx 时钟除以 8。当然，原因是输入不是 8 位字节的常规倍数。相反，它是一个 2 位的同步头，后面是 16 个字节。这额外的两位必须在某个地方得到考虑。规范没有要求任何特定的实现，但有一个解决方案是将时钟除以 8.125，如第 437 页的图 12-19 所示，以在 130 位时间内产生 16 个时钟边缘。

然后，当达到块边界时间时，可以使用块类型检测逻辑从反串行化器中取出额外的两位，以确保只有 8 位字节被传递到弹性缓冲区，反串行化器无论如何都需要检查。

为了解决这个问题，8.0 GT/s 数据速率的内部时钟实际上是 8.0 GHz/8.125 = 0.985GHz。这导致比通常用来描述 Gen3 带宽的 1.0GB/s 数据速率略低，但差异很小（比 1GB/s 低 1.5%），所以通常不被提及。

##### 12.4.2.2 解串器

如第 437 页图 12-19 所示，通过恢复的 Rx 时钟将传入的数据计时到每个通道的串行-并行转换器中。8 位符号被发送到弹性缓冲器，并由 Rx 时钟的一个版本进入弹性缓冲器，该版本已除以 8.125，以适当适应 130 位中的 16 字节。

##### 12.4.2.3 实现块对齐

训练期间发送的 EIEOS 用于识别 130 位块的边界。如第 438 页图 12-20 所示，这个有序集可以在比特流中被识别出来，因为它是由 00h 和 FFh 的字节交替出现的模式。当看到这种模式时，EIEOS 的最后一个符号被解释为块的边界，测试接下来的 130 位将显示边界是否正确。如果不是，逻辑就继续搜索这个模式。这个过程在规范中被描述为三个阶段：未对齐、对齐和锁定。

 

###### 12.4.2.3.1 未对齐阶段

**未对齐阶段。**接收端在经过一段时间的电气空闲后进入这个阶段，例如更改为 8.0GT/s 或从低功率链路状态退出后。在这个阶段，块对齐逻辑观察 EIEOS 的到来，因为交替字节的结尾必须与块的结尾相对应。当看到 EIEOS 时，调整对齐，逻辑进入下一阶段。在此之前，它还必须根据任何 SOS 的到来调整其块的对齐。

###### 12.4.2.3.2 对齐阶段

**对齐阶段。**在这个阶段，接收端继续监测 EIEOS，并在看到 EIEOS 时对其位和块对齐进行任何必要的调整。然而，由于他们已经初步确定了块边界，他们现在也可以搜索 SDS（数据流的开始）有序集，以表明数据流的开始。当看到 SDS 时，接收端就进入了锁定阶段。在此之前，它还必须根据 SOS 的到来调整其块对齐。如果检测到未定义的同步头（值为 00b 或 11b），允许接收端返回到未对齐阶段。规范指出，这将在链路训练期间发生，当 EIEOS 后面是一个 TS 有序集时。

###### 12.4.2.3.3 锁定阶段。

**锁定阶段。**一旦接收端达到这个阶段，它就不再调整其块对齐。相反，它现在期望在 SDS 之后看到一个数据块，如果此时必须重新调整对齐，一些未对齐的数据可能会丢失。如果检测到未定义的同步头，则允许接收端返回到未对齐或对齐阶段。只要数据流处理停止，接收端可以被指示从锁定阶段转换到其他阶段之一（关于数据流的规则，请参见第 413 页“数据流和数据块”）。

###### 12.4.2.3.4 特殊情况：环回(Loopback)

**特殊情况：环回。**在讨论块对齐时，规范描述了当链路处于环回模式时的情况。环回主机（Loopback Master）必须能够在环回期间调整对齐，并允许发送 EIEOS，并在 Loopback.Active 期间回传检测到的 EIEOS 的基础上调整其接收端。环回从机（Loopback Slave）必须能够在 Loopback.Entry 期间调整对齐，但不能在 Loopback.Active 期间调整对齐。当从机开始回环比特流时，从机的接收端被认为处于锁定阶段。

##### 12.4.2.4 区块类型检测

一旦实现了块对齐，接收端就可以识别进入的块的起始时间，并检查前两位，以确定是两种可能的类型中的哪一种。有序集块只对物理层感兴趣，所以它们不会被转发到更高的层，但数据块会被转发。当检测到同步头时，该信息被信号传递给物理层的其他部分，以确定是否应从进入更高层的字节流中删除当前块。时钟恢复机制和同步头检测有效地完成了必须在物理层进行的从 130 位到 128 位的转换。

请注意，由于每个通道的块信息是相同的，这个逻辑可能只为一个通道实现，例如第 436 页图 12-18 中所示的通道 0。但是，如果支持不同的链路宽度和通道反转，那么更多的通道将需要包含这种逻辑，以确保始终有一个活动的通道有这种逻辑可用。例如，能够作为通道 0 运行的每条通道都将实现它，但只有当前作为通道 0 的那条通道将使用它。还要注意的是，由于规范没有给出这方面的细节，这里讨论和说明的示例只是对可行实现的猜测。

#### 12.4.3 接收端时钟补偿逻辑

##### 12.4.3.1 背景

8.0 GT/s 的时钟要求与早期规范版本相同：两个链路伙伴的时钟必须在中心频率的+/-300 ppm（百万分之一）范围内，这导致（在最坏的情况下）每 1666 个时钟就会获得或失去一个时钟。

##### 12.4.3.2 弹性缓冲区的作用

如第 441 页图 12-21 所示，使用恢复的时钟将接收到的符号计时到弹性缓冲器中，并使用接收端的本地时钟进行时钟输出。弹性缓冲器像以前一样通过添加或删除 SKP 符号来补偿频率差，但现在它一次添加四个符号，而不是一次仅添加一个符号。当 SKP 有序集到达时，监控缓冲器状态的控制逻辑会进行评估。如果本地时钟运行速度较快，缓冲区将接近下溢状态，逻辑可以通过在 SOS 到达时追加四个额外的 SKP 来补偿，以快速重新填充缓冲区。另一方面，如果恢复的时钟运行得更快，缓冲区将接近溢出状态，逻辑将通过删除四个 SKP 来补偿溢出情况，以便在看到 SOS 时快速排空缓冲区。

 

Gen3 发送端每 370 至 375 个块安排一次 SOS，但和以前一样，只能在块边界发送。如果在安排 SOS 时，有一个数据包正在进行中，它们会被累积并在下一个数据包边界插入。然而，与较低的数据速率不同的是，在 8.0GT/s 下不允许有两个连续的 SOS。它们必须由用数据块隔开。接收端必须能够容忍由设备支持的最大数据包有效载荷大小分隔的 SOS。

事实上，仅以 4 个符号为增量进行调整，这可能会影响到弹性缓冲区的深度，因为在应用任何补偿之前，需要看到 4 的差值，而一个大的数据包可能正在进行中，这本来是适当的时间。由于这个原因，在确定这个缓冲区的最佳尺寸时需要谨慎，所以让我们考虑一个例子。在每块 16 个符号的情况下，375 块的 SOS 之间允许的时间等于 6000 个符号时间。将其除以最坏情况下获得或失去一个时钟的时间 1666，意味着在此期间可以获得或失去 3.6 个时钟。如果最大的 TLP（4KB）是在下一个 SOS 发送之前开始的，那么对于一个 x1 链路来说，它的整体延迟大约是 6000+4096=10096 符号时间，这意味着获得或失去 10096/1666=6.06 时钟。因此，如果支持 4KB 大小的 TLPs，缓冲器可能被设计成在保证 SOS 到达之前处理 7 个过多或过少的符号。可能发生的情况是，在第一个 SOS 被发送之前，已经安排了两个 SOS。在较低的数据速率下，排队的 SOS 是背对背发送的，但对于 8.0GT/s 来说，它们不会被发送，必须用一个数据块隔开。每当 SOS 到达接收端时，它可以添加或删除 4 个 SKP 符号，以快速填充或耗尽缓冲区，避免出现问题。

#### 12.4.4 通道与通道之间的倾斜

##### 12.4.4.1 通道间的飞行时间差异

对于多通道链路，通道之间的到达时间差异在接收端上通过延迟早期到达的时间来自动纠正，直到它们全部匹配。该规范允许通过设计者喜欢的任何方式来实现，但在弹性缓冲器之后使用数字延迟有一个好处，即到达时间差异现在被数字化为接收端的本地符号时钟。如果一个通道的输入在一个时钟沿上，而另一个没有，它们之间的差异将以时钟周期来衡量，所以早到的通道可以简单地延迟适当数量的时钟，使其与晚到的通道保持一致（见第 444 页的图 12-22）。事实上，接收端的最大允许偏移量是时钟周期的倍数，这一事实使这一点变得容易，并推断出规范编写者可能已经考虑到了这种实现方式。正如规范中所定义的那样，接收端必须能够为 Gen1（5 个符号时间的时钟，每个符号 4ns）和 Gen2（4 个符号时间的时钟，每个符号 2ns）去偏移（de-skewing）20ns，为 Gen3（6 个符号时间的时钟，每个符号 1ns）去偏移 6ns。

##### 12.4.4.2 去偏移的契机

必须在所有通道上同时看到相同的符号才能执行去偏移，任何有序集都可以。然而，去偏移只在 L0s、恢复（Recovery）和配置（Configuration）LTSSM 状态下执行。特别是，它必须作为一个条件来完成：

• 离开 Configuration.Complete

• 离开 Configuration.Idle 或 Recovery.Idle 后开始处理数据流

• 离开 Recovery .RcvrCfg

• 离开 Rx_L0s.FTS

如果偏移值在 L0 状态下发生变化（例如，基于温度或电压变化），则可能会发生接收端错误并导致重放 TLP。如果问题持续存在，链路最终将转换到恢复状态，并在那里进行去偏移处理。规范指出，虽然设备在 L0 状态下不允许对其链路进行去偏移，但在此状态下必须定期发送的 SOS 包含 LFSR 值，目的是帮助外部工具完成这一工作。这些工具不受数据流规则的限制，可以搜索 SOS，并使用这些模式来实现数据流中的位锁定、块对齐和通道间的去偏移。

规范指出，当离开 L0s 时，发送端将发送一个 EIEOS，然后是正确数量的 FTS，并在每 32 个 FTS 后插入另一个 EIEOS，然后是最后一个 EIEOS，以协助块对齐，最后是一个 SDS 有序集，目的是除了启动数据流外还能去偏移。

14.4.4.3 接收端通道间的去偏移能力

可以理解的是，发送端只允许引入最小的偏移量，以便将剩余的偏移预算用于覆盖路由差异和其他变化。接收端可校正的允许偏差量如第 443 页的表 12-5 所示，可以看出，这种偏差很容易与 Gen3 的符号次数相对应，就像早期数据速率一样。这使得在弹性缓冲器之后使用延迟寄存器来完成去偏移的选择与前面为 Gen1/Gen2 物理层实现所描述的一样。

 

当使用 8b/10b 编码时，一种明确的去偏移机制是监视 COM 控制字符，它必须同时出现在所有通道上。128b/130b 没有这个选项，但有序集仍然同时出现在所有通道上，如 SOS、SDS 和 EIEOS。因此，尽管在对通道进行去偏移时要寻找的模式不同，但过程也可能非常相同。

 

#### 12.4.5 解扰器

##### 12.4.5.1 综述

接收端遵循与发送端完全相同的加扰多项式生成规则，并简单地将相同的值再次与输入数据进行 XOR 以恢复原始信息。与发送端一样，他们可以为每个通道实现一个单独的 LFSR，或者只实现一个。

##### 12.4.5.2 禁用解扰

与 Gen1/Gen2 数据速率不同，在 Gen3 模式下，不能禁用解扰，因为它在促进时钟恢复和信号完整性方面起着重要作用。在较低的速率下，TS1 和 TS2 控制字节中的“禁用加扰”位将被用来通知链路邻居加扰正在被关闭。在 8.0GT/s 以及更高的速率该位是保留的。

#### 12.4.6 字节拆分(Byte Un-Striping)

这个逻辑与 Gen1 或 Gen2 的实现基本相同。在某些时候，Gen3 的字节流和较低数据速率的字节流必须混合在一起，第 445 页图 12-23 中的示例显示了在拆分（un-striping）逻辑之前发生的情况。

 

#### 12.4.7 数据包过滤

由字节拆分（un-striping）逻辑提供的串行字节流包含 TLPs、DLLPs、逻辑空闲（IDLs）和有序集。逻辑空闲字节和有序集在这里被消除，不被转发到数据链路层。剩下的是 TLPs 和 DLLPs，它们与数据包类型的指示符一起被转发。

#### 12.4.8 接收缓冲区(Rx Buffer)

Rx 缓冲区保存收到的 TLPs 和 DLLPs，直到数据链路层能够接受它们。规范中没有描述数据链路层的接口，因此设计者可以自由选择总线宽度等细节。通道越宽，时钟频率就越低，但需要更多的信号和逻辑来支持它。

### 12.5 关于 128b/130b Loopback 的注意事项

规范特别说明了环回模式在更高速率下的操作。基本规则可以归纳如下：

• 环回主机（Loopback master）必须发送实际的有序集或数据块，但在从数据块变为有序集或反之亦然时，他们不需要遵循正常的协议规则。换句话说，SDS 有序集和 EDS 标记不是必需的。从机必须不期望或检查它们的存在。

• 主机必须像往常一样发送 SOS，并且必须允许环回流中的 SKP 符号数量不同，因为接收端将进行时钟补偿。

• 允许环回从机通过一次添加或删除 4 个 SKP 符号来修改 SOS，就像他们通常为时钟补偿所做的那样，但产生的 SOS 仍必须遵循正确的格式规则。

• 除了 SOS 和 EIEOS 之外，所有内容都应该完全按照发送时的情况环回，因为 SOS 可以像刚才描述的那样发生变化，而 EIEOS 和 EIOS 在环回中都有明确的用途，应该避免使用。

• 如果从机无法获取块对齐，它将无法按照收到的所有位进行环回，并允许根据需要添加或删除符号以继续操作。

------

原文： Mindshare

译者： Brook

校对:	LJGibbs

欢迎参与 《Mindshare PCI Express Technology 3.0 一书的中文翻译计划》

https://gitee.com/ljgibbs/chinese-translation-of-pci-express-technology

